
## Quick example of using Python and SQL Enums

Showing the use of Python and SQL Enums managed by the Alembic versioning system.

### the tech
Flask, Flask-SQLAlchemy, Migrate, Alembic

## The parts it uses
This uses a postgres database.

Alembic to create the database migrations.

SQLAlchemy to manage the ORM.

### The steps to demo
1. Use the Makefile to setup the environment.
```bash
make setup
```

2. Create the database
```bash
 ./create_db.sh
 ```

3. Initialize and alembic versioning
```bash
 flask db init
 ```

See the State Enum, you can look at the file for the BaseEnum definition, but the take away here is a valid Python Enum is declared.
 ```python
 # sql_enum/models/business.py
...
class State(BaseEnum):
    """Enum for the Business state."""
    ACTIVE = auto()
    HISTORICAL = auto()
...
 ```
The use of the Enum in a SQLAlchemy derived class.
```python
class Business(db.Model):
    """Business data access object."""
    __tablename__ = 'businesses'
    id = db.Column(db.Integer, primary_key=True)
    state = db.Column('state', db.Enum(State))
```

4. Create a database migration.
```bash
 flask db migrate -m "Initial migration."
 ```
 You should see a python file create in ```migrations/versions``` with the following contents. You can see the Enum values assigned to the SQL Enum type.
```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('businesses',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('state', sa.Enum('ACTIVE', 'HISTORICAL', name='state'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###
```

5. Do a database migration
```bash
flask db upgrade
```
The database should look like.
```sql
sql_enum=# \d businesses
                            Table "public.businesses"
 Column |  Type   | Collation | Nullable |                Default
--------+---------+-----------+----------+----------------------------------------
 id     | integer |           | not null | nextval('businesses_id_seq'::regclass)
 state  | state   |           |          |
Indexes:
    "businesses_pkey" PRIMARY KEY, btree (id)
```
With an Enum as a constraint on the table.
```sql
sql_enum=# SELECT unnest(enum_range(NULL::state));
   unnest
------------
 ACTIVE
 HISTORICAL
(2 rows)
```
### Updating the existing model
Alter the State Enum, by adding in a Liquidation value.
```python
class State(BaseEnum):
    """Enum for the Business state."""
    ACTIVE = auto()
    HISTORICAL = auto()
    LIQUIDATION = auto()
```

1. Create a migration.
```bash
flask db migrate -m "add_liquidation_state"
```
the output is surprising as 
```
INFO  [alembic.env] No changes in schema detected.
```
So haven't quite figurued out how to autogenerate those changes to the Enum, as they are linked to an ORM class.
We'll create an empty revision to hold the change ourselves for now.

Solution in the branch **liquidation**

```bash
flask db revision -m "add_liquidation_state"
```
Change the file to have the following setup.
Luckily we can ALTER Types in Postgres via Alembic, but we also have to downgrade the column through a set of steps.

We may have to add multiple columns and drop them to provide more up time, but this is for another demo and maybe assing in my favourite, launchdarkly feaure flags.

For now, this works too, with minor availabilty impact.
```python
def upgrade():
    op.execute("ALTER TYPE state ADD VALUE 'LIQUIDATION'")


def downgrade():
    op.execute("ALTER TYPE state RENAME TO state_previous")
    op.execute("CREATE TYPE state AS ENUM('ACTIVE', 'HISTORICAL')")
    op.execute((
        "ALTER TABLE businesses ALTER COLUMN state TYPE state USING "
        "state::text::state"
    ))
    op.execute("DROP TYPE state_previous")
```
